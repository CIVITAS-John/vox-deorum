#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import ts from 'typescript';

// Get current directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const dir = __dirname;

// Parse TypeScript file to extract property names and detect array types
function extractPropertyNames(filePath) {
  const sourceCode = fs.readFileSync(filePath, 'utf8');
  const sourceFile = ts.createSourceFile(
    filePath,
    sourceCode,
    ts.ScriptTarget.ES2020,
    true
  );

  const properties = [];

  function isArrayType(node) {
    // Check if this is z.array() or z.number().array() or similar
    if (ts.isCallExpression(node)) {
      if (ts.isPropertyAccessExpression(node.expression) &&
          ts.isIdentifier(node.expression.name) &&
          node.expression.name.text === 'array') {
        return true;
      }
      // Check for chained calls like z.number().array()
      if (ts.isPropertyAccessExpression(node.expression)) {
        return isArrayType(node.expression.expression);
      }
    }
    return false;
  }

  function isBooleanType(node) {
    // Check if this is z.boolean()
    if (ts.isCallExpression(node)) {
      if (ts.isPropertyAccessExpression(node.expression) &&
          ts.isIdentifier(node.expression.name) &&
          node.expression.name.text === 'boolean') {
        return true;
      }
      // Check for z.union([...]) that contains boolean
      if (ts.isPropertyAccessExpression(node.expression) &&
          ts.isIdentifier(node.expression.name) &&
          node.expression.name.text === 'union') {
        // Check if any of the union members is a boolean
        if (node.arguments.length > 0 && ts.isArrayLiteralExpression(node.arguments[0])) {
          const unionArray = node.arguments[0];
          for (const element of unionArray.elements) {
            if (isBooleanType(element)) {
              return true;
            }
          }
        }
      }
      // Check for chained calls like z.boolean().optional() or z.union(...).transform()
      if (ts.isPropertyAccessExpression(node.expression)) {
        return isBooleanType(node.expression.expression);
      }
    }
    return false;
  }

  function visit(node) {
    // Look for z.object() calls
    if (ts.isCallExpression(node) &&
        ts.isPropertyAccessExpression(node.expression) &&
        ts.isIdentifier(node.expression.name) &&
        node.expression.name.text === 'object' &&
        node.arguments.length > 0) {

      const arg = node.arguments[0];
      // Check if it's an object literal
      if (ts.isObjectLiteralExpression(arg)) {
        arg.properties.forEach(prop => {
          if (ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name)) {
            const propName = prop.name.text;
            const isArray = isArrayType(prop.initializer);
            const isBoolean = isBooleanType(prop.initializer);

            // Add prefix based on type
            let finalName = propName;
            if (isArray) {
              finalName = `*${propName}`;
            } else if (isBoolean) {
              finalName = `!${propName}`;
            }

            properties.push(finalName);
          }
        });
      }
    }

    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
  return properties;
}

// Get all TypeScript event schema files
const files = fs.readdirSync(dir)
  .filter(file => file.endsWith('.ts') &&
                  file !== 'index.ts' &&
                  !file.startsWith('generate'))
  .sort();

// Generate property array definitions inside the function
const eventArrayDefinitions = [];
const eventMapEntries = [];

files.forEach(file => {
  const basename = path.basename(file, '.ts');
  const filePath = path.join(dir, file);

  try {
    const properties = extractPropertyNames(filePath);
    const varName = `props_${basename}`;

    if (properties.length > 0) {
      const propsQuoted = properties.map(p => `"${p}"`);
      // Static array inside function with NULL terminator
      eventArrayDefinitions.push(`    static const char* ${varName}[] = {${propsQuoted.join(', ')}, NULL};`);
      eventMapEntries.push(`        schemas["${basename}"] = ${varName};`);
    } else {
      // Empty event - just NULL
      eventArrayDefinitions.push(`    static const char* ${varName}[] = {NULL};`);
      eventMapEntries.push(`        schemas["${basename}"] = ${varName};`);
    }
  } catch (error) {
    console.warn(`Warning: Could not parse ${file}: ${error.message}`);
    const varName = `props_${basename}`;
    eventArrayDefinitions.push(`    static const char* ${varName}[] = {NULL};`);
    eventMapEntries.push(`        schemas["${basename}"] = ${varName};`);
  }
});

// Generate the C++ header file
const headerContent = `// Auto-generated file - DO NOT EDIT
// Generated by generate-event-hpp.js from TypeScript event schemas
// Compatible with MSVC 2008

#pragma once

#include <map>
#include <string>

// Get event schemas map: event name -> NULL-terminated property array
std::map<std::string, const char**> GetEventSchemas();
`;

// Generate the C++ implementation file
const cppContent = `// Auto-generated file - DO NOT EDIT
// Generated by generate-event-hpp.js from TypeScript event schemas
// Compatible with MSVC 2008

#include "CvGameCoreDLLPCH.h"
#include "CvConnectionSchema.h"

// Static property arrays for each event
${eventArrayDefinitions.map(def => def.trim()).join('\n')}

std::map<std::string, const char**> GetEventSchemas() {
    static std::map<std::string, const char**> schemas;
    static bool initialized = false;

    if (!initialized) {
${eventMapEntries.join('\n')}
        initialized = true;
    }

    return schemas;
}
`;

// Write the C++ header file
const headerPath = path.join(dir, 'CvConnectionSchema.h');
fs.writeFileSync(headerPath, headerContent, 'utf8');

// Write the C++ implementation file
const cppPath = path.join(dir, 'CvConnectionSchema.cpp');
fs.writeFileSync(cppPath, cppContent, 'utf8');

console.log(`âœ“ Generated CvConnectionSchema.h and CvConnectionSchema.cpp with ${files.length} event schemas`);
console.log(`  Header: ${headerPath}`);
console.log(`  Implementation: ${cppPath}`);
console.log(`  Events processed: ${files.length}`);